package com.example.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface EstimatedDaysRepository extends JpaRepository<TableA, Long> {
    
    @Query("SELECT t.estimatedDays FROM TableA t WHERE t.product = :product AND t.transferMode = :transferMode AND t.orderType = :orderType")
    List<Double> findEstimatedDaysByConditions(
            @Param("product") String product,
            @Param("transferMode") String transferMode,
            @Param("orderType") String orderType);
}







package com.example.demo.service;

import com.example.demo.cache.ApplicationCacheManager;
import com.example.demo.exception.CustomException;
import com.example.demo.model.DbResponse;
import com.example.demo.model.EstimatedDaysRequest;
import com.example.demo.model.EstimatedDaysResponse;
import com.example.demo.repository.EstimatedDaysRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
public class CacheService {

    @Autowired
    private ApplicationCacheManager cacheManager;

    @Autowired
    private DbService dbService;

    @Autowired
    private EstimatedDaysRepository estimatedDaysRepository;

    public List<EstimatedDaysResponse> getEstimatedDays(List<EstimatedDaysRequest> requests) {
        List<EstimatedDaysResponse> responses = new ArrayList<>();

        for (EstimatedDaysRequest request : requests) {
            validateRequest(request);
            
            // Try to get from cache first
            Optional<Double> cachedEstimatedDays = getFromCache(request);
            
            if (cachedEstimatedDays.isPresent()) {
                responses.add(createResponse(request, cachedEstimatedDays.get()));
                continue;
            }
            
            // If not in cache, try to get from main database
            Optional<Double> dbEstimatedDays = getFromMainDatabase(request);
            
            if (dbEstimatedDays.isPresent()) {
                responses.add(createResponse(request, dbEstimatedDays.get()));
                continue;
            }
            
            // If not found anywhere, get from PostgreSQL fallback
            Double postgresEstimatedDays = getFromPostgres(request);
            responses.add(createResponse(request, postgresEstimatedDays));
        }

        return responses;
    }

    private Optional<Double> getFromCache(EstimatedDaysRequest request) {
        List<DbResponse> cachedData = cacheManager.getCachedData(
            request.getProduct(), 
            request.getOrderType(), 
            request.getTransferMode()
        );

        if (cachedData != null) {
            return cachedData.stream()
                .filter(data -> data.getCedingPlatformCode().equals(request.getCedingPlatformCode()))
                .map(DbResponse::getEstimatedDays)
                .findFirst();
        }
        return Optional.empty();
    }

    private Optional<Double> getFromMainDatabase(EstimatedDaysRequest request) {
        // Implement your logic to fetch from main database if needed
        // Return Optional.empty() if not implemented
        return Optional.empty();
    }

    private Double getFromPostgres(EstimatedDaysRequest request) {
        List<Double> estimatedDaysList = estimatedDaysRepository.findEstimatedDaysByConditions(
            request.getProduct(),
            request.getTransferMode(),
            request.getOrderType()
        );
        
        if (!estimatedDaysList.isEmpty()) {
            // Return the first match (or implement your own logic for multiple results)
            return estimatedDaysList.get(0);
        }
        
        // Default fallback value if nothing found
        return -1.0;
    }

    // ... rest of your existing methods (validateRequest, createResponse, etc)
}




@Entity
@Table(name = "table_a")
public class TableA {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String product;
    private String orderType;
    private String transferMode;
    private Double estimatedDays;
    
    // Getters and setters
}


















public boolean isCacheInitialized() {
    Cache cache = cacheManager.getCache("estimatedDaysCache");
    return cache != null;
}



public List<EstimatedDaysResponse> getEstimatedDays(List<EstimatedDaysRequest> requests) {
    List<EstimatedDaysResponse> responses = new ArrayList<>();
    
    boolean cacheAvailable = cacheManager.isCacheInitialized();
    
    for (EstimatedDaysRequest request : requests) {
        validateRequest(request);
        
        Double estimatedDays;
        
        if (cacheAvailable) {
            // 1. Try cache first if available
            estimatedDays = tryGetFromCache(request)
                       // 2. Fallback to PostgreSQL if not in cache
                       .orElseGet(() -> getFromPostgres(request));
        } else {
            // Skip cache entirely if not available
            estimatedDays = getFromPostgres(request);
        }
        
        responses.add(createResponse(request, estimatedDays));
    }
    
    return responses;
}

private Optional<Double> tryGetFromCache(EstimatedDaysRequest request) {
    try {
        List<DbResponse> cachedData = cacheManager.getCachedData(
            request.getProduct(), 
            request.getOrderType(), 
            request.getTransferMode()
        );
        
        return cachedData.stream()
            .filter(data -> data.getCedingPlatformCode().equals(request.getCedingPlatformCode()))
            .map(DbResponse::getEstimatedDays)
            .findFirst();
    } catch (Exception e) {
        log.warn("Cache access failed, falling back to DB", e);
        return Optional.empty();
    }
}

private Double getFromPostgres(EstimatedDaysRequest request) {
    try {
        List<Double> results = estimatedDaysRepository.findEstimatedDaysByConditions(
            request.getProduct(),
            request.getTransferMode(),
            request.getOrderType()
        );
        
        if (!results.isEmpty()) {
            // Business logic: take first, average, etc.
            return results.get(0); 
        }
        return DEFAULT_ESTIMATED_DAYS; // e.g., -1.0
    } catch (Exception e) {
        log.error("Failed to fetch from PostgreSQL", e);
        return DEFAULT_ESTIMATED_DAYS;
    }
}
